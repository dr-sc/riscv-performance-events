[
    {
        "EventName": "RVV_SPEC.ALL",
        "EventCode": "0x0",
        "BriefDescription": "Number of RVV instructions executed",
        "PublicDescription": "Number of RVV instructions executed"
    },
    {
        "EventName": "RVV_SPEC.INT",
        "EventCode": "0x0",
        "BriefDescription": "Number of integer RVV instructions executed",
        "PublicDescription": "Number of integer RVV instructions executed"
    },
    {
        "EventName": "RVV_SPEC.FP",
        "EventCode": "0x0",
        "BriefDescription": "Number of floating point RVV instructions executed",
        "PublicDescription": "Number of floating point RVV instructions executed"
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.INT8",
        "EventCode": "0x0",
        "BriefDescription": "Number of 8-bit integer element operation executed",
        "PublicDescription": "Number of 8-bit integer element operation executed. For example, if we have SEW=8, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.INT8 counter by 16. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.INT8 will be incremented by 8. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.IGNMASK.INT8",
        "EventCode": "0x0",
        "BriefDescription": "Number of 8-bit integer element operation executed not taking into account masking",
        "PublicDescription": "Number of 8-bit integer element operation executed. For example, if we have SEW=8, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.IGNMASK.INT8 counter by 16. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.INT8 will still be incremented by 16. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.INT16",
        "EventCode": "0x0",
        "BriefDescription": "Number of 16-bit integer element operation executed",
        "PublicDescription": "Number of 16-bit integer element operation executed. For example, if we have SEW=16, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.INT16 counter by 8. Masked-out elements should not increment the counter - so in the previous example half of the lanes are masked the RVV_SPEC.ELEMENT.INT16 counter will be incremented by 4. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.IGNMASK.INT16",
        "EventCode": "0x0",
        "BriefDescription": "Number of 16-bit integer element operation executed not taking into account masking",
        "PublicDescription": "Number of 16-bit integer element operation executed. For example, if we have SEW=16, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.IGNMASK.INT16 counter by 8. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.INT16 counter will still be incremented by 8. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.INT32",
        "EventCode": "0x0",
        "BriefDescription": "Number of 32-bit integer element operation executed",
        "PublicDescription": "Number of 32-bit integer element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.INT16 counter by 4. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.INT32 counter will be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.IGNMASK.INT32",
        "EventCode": "0x0",
        "BriefDescription": "Number of 32-bit integer element operation executed not taking into account masking",
        "PublicDescription": "Number of 32-bit integer element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.IGNMASK.INT16 counter by 4. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.INT32 counter will still be incremented by 4. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.INT64",
        "EventCode": "0x0",
        "BriefDescription": "Number of 64-bit integer element operation executed",
        "PublicDescription": "Number of 64-bit integer element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.INT64 counter by 2. Masked-out elements should not increment the counter - so in the previous example half of the lanes are masked the RVV_SPEC.ELEMENT.INT64 counter will be incremented by 1. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.IGNMASK.INT64",
        "EventCode": "0x0",
        "BriefDescription": "Number of 64-bit integer element operation executed not taking into account masking",
        "PublicDescription": "Number of 64-bit integer element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector integer arith instruction - it should increment the RVV_SPEC.ELEMENT.IGNMASK.INT64 counter by 2. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.INT64 counter will still be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.FP_SINGLE",
        "EventCode": "0x0",
        "BriefDescription": "Number of single-precision floating point element operation executed",
        "PublicDescription": "Number of single-precision floating point element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV_SPEC.ELEMENT.FP_SINGLE counter by 4. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.FP_SINGLE counter will be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.IGNMASK.FP_SINGLE",
        "EventCode": "0x0",
        "BriefDescription": "Number of single-precision floating point element operation executed not taking into account masking",
        "PublicDescription": "Number of single-precision floating point element operation executed. For example, if we have SEW=32, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV_SPEC.ELEMENT.IGNMASK.FP_SINGLE counter by 4. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.FP_SINGLE counter will still be incremented by 4. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.FP_DOUBLE",
        "EventCode": "0x0",
        "BriefDescription": "Number of double-precision floating point element operation executed",
        "PublicDescription": "Number of double-precision floating point element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV_SPEC.ELEMENT.FP_DOUBLE counter by 2. Masked-out elements should not increment the counter - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.FP_DOUBLE counter will be incremented by 1. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    },
    {
        "EventName": "RVV_SPEC.ELEMENT.IGNMASK.FP_DOUBLE",
        "EventCode": "0x0",
        "BriefDescription": "Number of double-precision floating point element operation executed not taking into account masking",
        "PublicDescription": "Number of double-precision floating point element operation executed. For example, if we have SEW=64, LMUL=1, VLEN=128 and doing vector FP arith instruction - it should increment the RVV_SPEC.ELEMENT.IGNMASK.FP_DOUBLE counter by 2. Mask should not be taken into account - so in the previous example if half of the lanes are masked the RVV_SPEC.ELEMENT.FP_DOUBLE counter will still be incremented by 2. For multiply-add instructions each element operation should increment counter by 2 to account for both multiplication and addition."
    }
]